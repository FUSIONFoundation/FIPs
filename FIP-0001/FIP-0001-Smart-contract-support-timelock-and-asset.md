---
fip: 001
title: Smart contract support timelock and asset
author: Zongyuan
type: Standards
category: Core
status: Draft
created: 2020-02-12
---

Smart contract support timelock and asset
=====

## Simple Summary
This is a protocol to extend smart contract to support receiveing and sending Fusion timelock and asset.

## Abstract
This protocol define a special `receiveAsset` interface for smart contract to implement to support receiving Fusion timelock and asset, and define a precompiled smart contract for smart contract to call to support sending Fusion timelock and asset.

## Motivation
The motivation is to extend smart contract to support receiving and sending Fusion timelock and asset.

## Specification

### 1. Send Fusion timelock and asset

If a contract want to send out Fusion timelock and asset from the contract, it can call the precompiled smart contract at address `0x9999999999999999999999999999999999999999`, or inherit from the following `FSNContract` contract which has already encapsulate the calling in function `_sendAsset`.

``` js
contract FSNContract {
    address constant precompile = address(0x9999999999999999999999999999999999999999);

    event LogFusionAssetReceived(bytes32 indexed _asset, address indexed _from, uint256 _value, uint64 _start, uint64 _end, SendAssetFlag _flag);
    event LogFusionAssetSent(bytes32 indexed _asset, address indexed _to, uint256 _value, uint64 _start, uint64 _end, SendAssetFlag _flag);

    enum SendAssetFlag {
        UseAny,                                       // 0
        UseAnyToTimeLock,              // 1
        UseTimeLock,                           // 2
        UseTimeLockToTimeLock,  // 3
        UseAsset,                                    // 4
        UseAssetToTimeLock            // 5
    }

    function _sendAsset(bytes32 asset, address to, uint256 value, uint64 start, uint64 end, SendAssetFlag flag) internal returns (bool, bytes memory) {
        bytes memory input = abi.encode(1, asset, to, value, start, end, flag);
        return precompile.call(input);
    }
}
```

**precompile** - the precompiled contract's address, a constant value of `0x9999999999999999999999999999999999999999`

**LogFusionAssetReceived** - event generated by calling `receiveAsset` (introduce in next section)

**LogFusionAssetSent** - event generated by calling precompiled contract in `_sendAsset`

**SendAssetFlag** - an enum to control how to convert timelock and asset

enum values are:

``` js
UseAny,                                       // 0
UseAnyToTimeLock,              // 1
UseTimeLock,                           // 2
UseTimeLockToTimeLock,  // 3
UseAsset,                                    // 4
UseAssetToTimeLock            // 5
```

convert rules are:

1. If suffix is `ToTimeLock`(1,3,5), then the receiver will always get timelock, `otherwise`(0,2,4) if the time range is from now to forever, the receiver will get asset instead.
2. If prefix is `UseTimeLock`(2,3), then the sender can only spend timelock.
3. If prefix is `UseAsset`(4,5), then the sender can only spend asset.
4. If prefix is `UseAny`(0,1), the the sender can use timelock and asset together, but timelock first.

**_sendAsset** - encapsulate to call precompiled contract

``` js
function _sendAsset(bytes32 asset, address to, uint256 value, uint64 start, uint64 end, SendAssetFlag flag) internal returns (bool, bytes memory);

asset  - Fusion asset's unique ID
to        - receiver address
value - amount with uint of satoshi
start   - start time of timelock, 0 means now
end    - end time of timelock, 0 means forever
flag    - flag of type SendAssetFlag, explained above
```

### 2. Receive Fusion timelock and asset

If a contract want to receive Fusion timelock and asset from an Externally Owned Account(EOA), the contract must implement the following 'receiveAsset' interface.

``` js
function receiveAsset(bytes32 assetID, uint64 startTime, uint64 endTime, SendAssetFlag flag, uint256[] memory extraInfo) payable public returns (bool success);

assetID        - Fusion asset's unique ID
startTime   - start time of timelock, 0 means now
endTime     - end time of timelock, 0 means forever
flag                - flag of type SendAssetFlag, explained above
extraInfo     - extra info for the contract designer

and the received value is equal to msg.value
```

### 3. Example

``` js
contract FSNExample is FSNContract {
    address owner;
    modifier onlyOwner {
        require(msg.sender == owner, "only owner");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function receiveAsset(bytes32 assetID, uint64 startTime, uint64 endTime, SendAssetFlag flag, uint256[] memory extraInfo) payable public returns (bool success) {
        return true;
    }

    function sendAsset(bytes32 asset, address to, uint256 value, uint64 start, uint64 end, SendAssetFlag flag) onlyOwner public returns (bool success) {
        (success,) = _sendAsset(asset, to, value, start, end, flag);
        require(success, "call sendAsset failed");
        return true;
    }
}
```

## Rationale

**Current Limitations**

The current smart contract did not support Fusion timelock and asset.

**Rationale**

On Fusion blockchain we need to extend smart contract to support Fusion timelock and asset, to make the smart contract more suitable for Fusion blockchain.

## Backwards Compatibility
This FIP introduces no backward compatibility issues. In the future, the new version protocol has to keep these interfaces.

## Implementation
This FIP implememtation needs to add precompiled smart contract, and modify EVM behavior for special `receiveAsset` interface. It require source code modification and a hard fork to enable its function.

## Security Considerations
For security, we have also added the following limitations:
1. Precompiled contract `0x9999999999999999999999999999999999999999` can only be called by contract to support sending Fusion timelock and asset.
2. When smart contract implements `receiveAsset` interface, `receiveAsset` can only be called by EOA to prevent input data from being modified.
