---
fip: 001
title: Smart contract support timelock and asset
author: Zongyuan
type: Standards
category: Core
status: Draft
created: 2020-02-12
---

Smart Contract Support for Fusion Timelock and Assets
=====

## Simple Summary
This protocol extends smart contract support for receiveing and sending Fusion timelocks and assets.

## Abstract
This protocol defines:
1. a `receiveAsset` interface for smart contracts to support receiving Fusion timelocks and assets, and 
1. a precompiled smart contract to support sending Fusion timelocks and assets.

## Motivation
The motivation is to extend smart contract support for receiving and sending Fusion timelocks and assets.

## Specification

### 1. Send Fusion Timelock and Asset

If a contract wants to send Fusion timelocks and assets from the contract, it can either:
1. call the precompiled smart contract at address `0x9999999999999999999999999999999999999999`, or 
1. inherit from the following `FSNContract` contract which encapsulates the calling of function `_sendAsset`.

``` js
contract FSNContract {
    address constant precompile = address(0x9999999999999999999999999999999999999999);

    event LogFusionAssetReceived(bytes32 indexed _asset, address indexed _from, uint256 _value, uint64 _start, uint64 _end, SendAssetFlag _flag);
    event LogFusionAssetSent(bytes32 indexed _asset, address indexed _to, uint256 _value, uint64 _start, uint64 _end, SendAssetFlag _flag);

    enum SendAssetFlag {
        UseAny,                                       // 0
        UseAnyToTimeLock,              // 1
        UseTimeLock,                           // 2
        UseTimeLockToTimeLock,  // 3
        UseAsset,                                    // 4
        UseAssetToTimeLock            // 5
    }

    function _sendAsset(bytes32 asset, address to, uint256 value, uint64 start, uint64 end, SendAssetFlag flag) internal returns (bool, bytes memory) {
        bytes memory input = abi.encode(1, asset, to, value, start, end, flag);
        return precompile.call(input);
    }
}
```
#### Term Definition
**precompile** - The precompiled contract's address, a constant value of `0x9999999999999999999999999999999999999999`.

**LogFusionAssetReceived** - Event generated by calling `receiveAsset`, introduced in Section 2 of this article.

**LogFusionAssetSent** - Event generated by calling precompiled contract in `_sendAsset`.

**SendAssetFlag** - An enum to control how to convert timelock and asset.

enum values are:

``` js
UseAny,                                       // 0
UseAnyToTimeLock,              // 1
UseTimeLock,                           // 2
UseTimeLockToTimeLock,  // 3
UseAsset,                                    // 4
UseAssetToTimeLock            // 5
```

convert rules are:

1. If suffix is `ToTimeLock`(1,3,5), then the receiver will always get timelock, `otherwise`(0,2,4) if the time range is from now to forever, the receiver will get asset instead.
2. If prefix is `UseTimeLock`(2,3), then the sender can only spend timelock.
3. If prefix is `UseAsset`(4,5), then the sender can only spend asset.
4. If prefix is `UseAny`(0,1), the the sender can use timelock and asset together, but timelock first.

**_sendAsset** - encapsulate to call precompiled contract

``` js
function _sendAsset(bytes32 asset, address to, uint256 value, uint64 start, uint64 end, SendAssetFlag flag) internal returns (bool, bytes memory);

asset  - Fusion asset's unique ID
to        - receiver address
value - amount with uint of satoshi
start   - start time of timelock, 0 means now
end    - end time of timelock, 0 means forever
flag    - flag of type SendAssetFlag, explained above
```

### 2. Receive Fusion Timelock and Asset

If a contract wants to receive Fusion timelocks and assets from an Externally Owned Account(EOA), the contract must implement the following 'receiveAsset' interface.

``` js
function receiveAsset(bytes32 assetID, uint64 startTime, uint64 endTime, SendAssetFlag flag, uint256[] memory extraInfo) payable public returns (bool success);

assetID        - Fusion asset's unique ID
startTime   - start time of timelock, 0 means now
endTime     - end time of timelock, 0 means forever
flag                - flag of type SendAssetFlag, explained above
extraInfo     - extra info for the contract designer

and the received value is equal to msg.value
```

### 3. Example

``` js
contract FSNExample is FSNContract {
    address owner;
    modifier onlyOwner {
        require(msg.sender == owner, "only owner");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function receiveAsset(bytes32 assetID, uint64 startTime, uint64 endTime, SendAssetFlag flag, uint256[] memory extraInfo) payable public returns (bool success) {
        return true;
    }

    function sendAsset(bytes32 asset, address to, uint256 value, uint64 start, uint64 end, SendAssetFlag flag) onlyOwner public returns (bool success) {
        (success,) = _sendAsset(asset, to, value, start, end, flag);
        require(success, "call sendAsset failed");
        return true;
    }
}
```

## Rationale

**Current Limitations**

The current smart contract did not support Fusion timelocks and assets.

**Rationale**

On Fusion blockchain we need to extend smart contract to support Fusion timelocks and assets, to leverage automation capabilities offered by blockchains.

## Backwards Compatibility
This FIP introduces no backward compatibility issues. In the future, the new version protocol has to keep these interfaces.

## Implementation
This FIP implememtation needs to add precompiled smart contract, and modify EVM behavior for the `receiveAsset` interface. It requires source code modification and a hard fork to enable functionality.

## Security Considerations
For security, we have also added the following limitations:
1. Precompiled contract `0x9999999999999999999999999999999999999999` can only be called by contracts to support sending Fusion timelock and asset.
2. When smart contract implements `receiveAsset` interface, `receiveAsset` can only be called by EOA to prevent input data from being modified.
